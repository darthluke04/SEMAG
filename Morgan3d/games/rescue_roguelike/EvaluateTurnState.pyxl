// evalutes turn_state for the given team.
// large numbers means better for team.
//
// currently, this is mostly written with win conditions where team == "enemy"
def evaluate_turn_state(turn_state, team):   
    let health_by_team = compute_health_by_team(turn_state)
    let health_of_team = 0
    let health_of_others = 0
    for the_health at the_team in health_by_team:
        if the_team:
            if the_team == team:
                health_of_team += the_health
            else:
                health_of_others += the_health

    return health_of_teamÂ² - health_of_others

// Returns true if this is a good candidate move.  
// This means the move is valid and the attack_vector makes sense.
// This is mostly here to rule out redundant attacks that might be
// generated by the CPUTurn.
def is_candidate_attack_vector(turn_state, unit, unit_spec, move_coord, attack_vector):
    // do not allow any attacks that are in the invalid rows.
    const attack_coord = move_coord + attack_vector

    if attack_coord.y >= BATTLE_GRID_SIZE.y - NUM_INVALID_ROWS_FROM_BOTTOM:
        return false

    const attack_name = unit_spec.attack.kind
    const attack_dist = manhattan(attack_vector)
    if attack_name == "gun":
        // only the directionality is important
        return attack_dist == 1
    else if attack_name == "melee":
        // only the directionality is important
        return attack_dist == 1
    else if attack_name == "grenade":
        const attack_range = unit_spec.attack.range
        return attack_dist >= attack_range[0] and attack_dist <= attack_range[1]
    else:
        assert(false)

    return false

def is_candidate_move(turn_state, unit, unit_spec, move_coord):
    // for now just check that it's a valid move
    return unit_has_path_to(turn_state, unit, unit_spec, move_coord)
    
def compute_health_by_team(turn_state):
    let ret = { }
    for obj in turn_state.objects:
        if obj.health < infinity:
            if not ret[obj.team]:
                ret[obj.team] = 0
            ret[obj.team] += obj.health
    return ret


def get_state_after_move_and_attack(turn_state, unit, move_coord, attack_vector):
    // execute the move and attack
    let eval_turn_state = deep_clone(turn_state)
    const attacker = get_object_by_id(eval_turn_state, unit.id)
    attacker.coord = xy(move_coord)

    if attack_vector:
        const attacker_spec = ObjectSpecs_YAML[attacker.obj_type]
        const attacker_action = attacker_spec.attack.kind
        let steps = compute_pending_steps_for_action(
            attacker_action,
            attacker,
            attacker_spec,
            attacker.coord + attack_vector
        )
        execute_pending_steps_until_done(
            eval_turn_state,
            steps
        )
    return eval_turn_state

def compute_num_rows(turn_state):
    return size(turn_state.tiles) / BATTLE_GRID_SIZE.x

def needs_more_tiles(turn_state):
    const num_rows = compute_num_rows(turn_state)
    if turn_state.map_offset + BATTLE_GRID_SIZE.y > num_rows:
        return true
    return false
    
